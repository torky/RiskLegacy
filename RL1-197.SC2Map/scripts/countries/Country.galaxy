const int maxBasesInCountry = 10; //Can be changed

struct Country {
    string name;
    unitgroup structures;
    int conscriptsSpawned;
    int conscriptSpawnLimit;
    int conscriptsSpawnedPerTurn;
    int[maxBasesInCountry] baseIDs;
    unit spawn;
    string flagTexture;
    string flagImage;
    int income;
    int owner;
};

const int totalCountries = 100; //100 is arbitrary. Just needs to be larger than the number of total countries
Country[totalCountries] countries;

void AddTextTags(int i){
    if(countries[i].income == 0) { return; }
    TextTagCreate(StringToText((countries[i].name + (": " + IntToString(countries[i].income)))), 25, UnitGetPosition(countries[i].spawn), 0.5, true, false, PlayerGroupAll());
    TextTagSetColor(TextTagLastCreated(), c_textTagColorText, Color(100.00, 100.00, 100.00));
}

void UpdateCountry(int countryID){
    structref<Country> country;
    int i;
    int newOwner;
    int oldOwner;
    int baseOwner;
    structref<Base> base;

    country = countries[countryID];
    oldOwner = country.owner;
    base = allBases[country.baseIDs[0]];
    newOwner = UnitGetOwner(base.structure);

    for(i = 1; i < country.income; i+=1){
        base = allBases[country.baseIDs[i]];
        baseOwner = UnitGetOwner(base.structure);
        if(baseOwner != newOwner){
            country.owner = 0;
            return;
        }
    }

    if(newOwner != oldOwner){
        country.conscriptsSpawned = 0;
    }
    
    country.owner = newOwner;
    UnitSetOwner(country.spawn, newOwner, true);
}

void InitializeBases () {
    int i;
    int count;
    int baseID = 0;
    int y;
    unit u;
    structref<Base> b;
    for (i = 0; i < totalCountries; i+=1) {
        count = countries[i].income;
        y = 0;
        for(;;count-=1){
            u = UnitGroupUnitFromEnd(countries[i].structures, count);
            if(u == null) {break;}
            InitializeBase(0, baseID, u);

            countries[i].baseIDs[y] = baseID;
            SetCountryIDOfUnit(allBases[baseID].defender, i);

            baseID+=1;
            y+=1;
        }
    }
}

void SetupConscripts(int countryID){
    int i;
    int count;
    structref<Country> country;

    country = countries[countryID];
    count = UnitGroupCount(country.structures, c_unitCountAlive);
    country.conscriptSpawnLimit = country.income * 2;
    country.conscriptsSpawned = 0;
    country.conscriptsSpawnedPerTurn = FixedToInt((IntToFixed(count) / 2.0) * 1.5);
}

trigger gt_SpawnConscripts;
int conscriptCountryID;
bool SpawnConscripts (bool testConds, bool runActions){
    int i;
    order trainMarine;
    int unitsToBeSpawned;
    int countryID;
    structref<Country> country;

    countryID = conscriptCountryID;
    country = countries[countryID];
    trainMarine = Order(AbilityCommand("BarracksTrain2", 0));

    if(country.owner != 0 && country.conscriptsSpawned < country.conscriptSpawnLimit){
        for (i = 0; i < country.conscriptsSpawnedPerTurn; i += 1){
            PlayerModifyPropertyInt(country.owner, c_playerPropMinerals, c_playerPropOperAdd, 1);
            UnitIssueOrder(country.spawn, trainMarine, c_orderQueueReplace);
            Wait(0.5, c_timeGame);
        }
        country.conscriptsSpawned += country.conscriptsSpawnedPerTurn;
    }

    return true;
}

void gt_SpawnConscripts_Init(){
    gt_SpawnConscripts = TriggerCreate("SpawnConscripts");
}

void RefreshConscripts(){
    int i;
    if(gt_SpawnConscripts == null){
        gt_SpawnConscripts = TriggerCreate("SpawnConscripts");
    }
    for(i = 0; i < totalCountries; i += 1){
        conscriptCountryID = i;
        TriggerExecute(gt_SpawnConscripts, false, false);
    }  
}