
struct Picked{
    int value;
    bool picked;
};

typedef Picked[16] PlayerArray;

void GeneratePickedPlayers(playergroup players, int count, arrayref<PlayerArray> pickedPlayers){
    int i;
    int p;
    for(i = 1; i <= count; i += 1){
        pickedPlayers[i-1].value = PlayerGroupPlayer(players, i);;
        pickedPlayers[i-1].picked = false;
    }
}

void DistributeTerritories(playergroup players) {
    int i;
    int count;
    int r;
    int p;
    int j;
    int c;
    structref<Base> b;
    int bi;

    int prevR = -1;
    int prevI = -1;

    PlayerArray pickedPlayers;

    count = PlayerGroupCount(players);
    j = -1;
    c = 0;
    i = 0;
    while(i < totalCountries){
        if(j == -1){
            //Reset # of random players, and picked players
            j = count-1;
            GeneratePickedPlayers(players, count, pickedPlayers);
        }
        bi = countries[i].baseIDs[c];
        b = allBases[bi];

        if(bi == 0){
            c = 0;
            i+=1;
            if(i == totalCountries) { break; }
            //Skip 1 income countries
            while(UnitGroupCount(countries[i].structures, c_unitCountAll) == 1){ 
                i+=1;
                if(i == totalCountries) { break; }
            }
            bi = countries[i].baseIDs[c];
            b = allBases[bi];
        }

        //Pick next random player
        r = RandomInt(0, j);
        while(pickedPlayers[r].picked) {
            r+=1;
        }

        //Insure picked player is not the same player previously picked
        while(prevI == i && prevR == r){
            r = RandomInt(0, j);
            while(pickedPlayers[r].picked) {
                r+=1;
            }
        }

        //Mark picked player as picked
        pickedPlayers[r].picked = true;
        p = pickedPlayers[r].value;
        
        SetBaseOwnership(b, p);
        prevR = r;
        prevI = i;
        c+=1;
        j-=1;
    }
    
}




