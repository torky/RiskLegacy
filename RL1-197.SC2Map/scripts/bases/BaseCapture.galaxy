// Radius 6.0

unit FindNewFriendlyDefender(unit baseStructure){
    unitgroup potentialDefenders;
    int count;
    unit newDefender;
    unit allyUnit;
    unitfilter filter;
    int baseID = GetBaseIDOfUnit(baseStructure);
    structref<Base> base = allBases[baseID];

    filter = UnitFilter(0, 
        0, 
        (1 << c_targetFilterStructure) | (1 << c_targetFilterMissile) | (1 << c_targetFilterDestructible), 
        (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
    );

    allyUnit = null;
    potentialDefenders = UnitGroup(null, c_playerAny, RegionCircle(base.position, 1.6), filter, 0);
    count = UnitGroupCount(potentialDefenders, c_unitCountAll);
    for (;; count -= 1) {
        newDefender = UnitGroupUnitFromEnd(potentialDefenders, count);
        if (newDefender == null) { break; }
        if (UnitGetOwner(newDefender) == UnitGetOwner(base.structure)){
            return newDefender;
        }else if(PlayerGetAlliance(UnitGetOwner(newDefender), c_allianceIdTrade, UnitGetOwner(base.structure))){
            allyUnit = newDefender;
        }
        

    }
    return allyUnit;
}

unit FindNewAttackerDefender(unit killingUnit){
    fixed radius = 6.0;
    unitgroup potentialDefenders;
    unit current;
    fixed currentHealth;
    fixed lowestHealth;
    fixed maxHealth;
    fixed currentMaxHealth;
    unit newDefender;
    int count;
    unitfilter filter;

    filter = UnitFilter(0, 
        0, 
        (1 << c_targetFilterStructure) | (1 << c_targetFilterMissile) | (1 << c_targetFilterDestructible), 
        (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
    );

    potentialDefenders = UnitGroup(null, UnitGetOwner(killingUnit), RegionCircle(UnitGetPosition(killingUnit), radius), filter, 0);
    newDefender = killingUnit;
    lowestHealth = UnitGetPropertyFixed(killingUnit, c_unitPropLife, c_unitPropCurrent);
    maxHealth = UnitGetPropertyFixed(killingUnit, c_unitPropLifeMax, c_unitPropCurrent);

    count = UnitGroupCount(potentialDefenders, c_unitCountAll);
    for(;;count-=1){
        current = UnitGroupUnitFromEnd(potentialDefenders, count);
        if(current == null) {break;}
        currentHealth = UnitGetPropertyFixed(current, c_unitPropLife, c_unitPropCurrent);
        currentMaxHealth = UnitGetPropertyFixed(current, c_unitPropLifeMax, c_unitPropCurrent);

        if(!UnitHasBehavior2(current, "Defender") && 
        (
            (
                currentHealth < lowestHealth &&
                currentHealth > 0 &&
                currentMaxHealth == maxHealth
            )
            ||
            (
                currentMaxHealth < maxHealth
            )
        )){
            newDefender = current;
            lowestHealth = currentHealth;
            maxHealth = currentMaxHealth;
        }
    }

    if(UnitHasBehavior2(newDefender, "WaterUnit")){
        UnitCreate(1, "Marine", c_unitCreateIgnorePlacement, UnitGetOwner(killingUnit), UnitGetPosition(killingUnit), 0);
        newDefender = UnitLastCreated();
    }

    return newDefender;
}

trigger gt_BaseCapture;

bool BaseCapture(bool testConds, bool runActions){
    unit dyingUnit;
    unit killingUnit;
    unit newDefender;
    int baseID;
    int oldOwner;
    int newOwner;
    unitgroup spawns;
    structref<Base> base;

    dyingUnit = EventUnit();
    killingUnit = EventUnitDamageSourceUnit();
    baseID = GetBaseIDOfUnit(dyingUnit);
    base = allBases[baseID];
    oldOwner = UnitGetOwner(base.structure);

    if(dyingUnit == base.defender){
        newDefender = FindNewFriendlyDefender(base.structure);
        if(newDefender == null){
            newDefender = FindNewAttackerDefender(killingUnit);
        }else if(PlayerGetAlliance(UnitGetOwner(newDefender), c_allianceIdTrade, oldOwner) &&
        UnitGetOwner(newDefender) != oldOwner){
            return true;
        }
        newOwner = UnitGetOwner(newDefender);

        SwapDefender(newDefender, baseID);
        SetBaseOwnership(baseID, newOwner);

        if(newOwner != oldOwner){
            IncrementCards(newOwner, base.structure);
        }

        UpdateCountry(GetCountryIDOfUnit(base.defender));
        UnitControlGroupClear(newOwner, 9);

        spawns = UnitGroup("SpawnZone", newOwner, RegionPlayableMap(), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
        UnitControlGroupClear(newOwner, 9);
        UnitControlGroupAddUnits(newOwner, 9, spawns);

        spawns = UnitGroup("SpawnZone", oldOwner, RegionPlayableMap(), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
        UnitControlGroupClear(oldOwner, 9);
        UnitControlGroupAddUnits(oldOwner, 9, spawns);

        libNtve_gf_AttachActorToUnit(base.defender, "TimeWarpLaunch", "Ref_Origin");
    }

    return true;
}

void gt_BaseCapture_Init () {
    gt_BaseCapture = TriggerCreate("BaseCapture");
    TriggerAddEventUnitDied(gt_BaseCapture, null);
}